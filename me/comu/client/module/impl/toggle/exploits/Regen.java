package me.comu.client.module.impl.toggle.exploits;

import me.comu.api.event.Listener;
import me.comu.client.events.MotionUpdateEvent;
import me.comu.client.module.ModuleType;
import me.comu.client.module.ToggleableModule;
import me.comu.client.properties.EnumProperty;
import me.comu.client.properties.NumberProperty;
import me.comu.client.utils.ClientUtils;
import net.minecraft.block.Block;
import net.minecraft.block.BlockAir;
import net.minecraft.block.BlockHopper;
import net.minecraft.network.play.client.C03PacketPlayer;
import net.minecraft.potion.Potion;
import net.minecraft.util.AxisAlignedBB;
import net.minecraft.util.BlockPos;
import net.minecraft.util.MathHelper;

public final class Regen extends ToggleableModule
{
    private final EnumProperty<Mode> mode = new EnumProperty<>(Mode.POTION, "Mode", "m");
    private final NumberProperty<Float> health = new NumberProperty<>(20F, 1F, 20F, 1F, "Health", "h", "<3");
    private final NumberProperty<Float> packets = new NumberProperty<>(500F, 0F, 6000F, 100F, "Packets", "packet", "p");

    public Regen()
    {
        super("Regen", new String[] {"regen", "fastheal"}, 0xFFA9D490, ModuleType.EXPLOITS);
        this.offerProperties(mode, health, packets);
        this.listeners.add(new Listener<MotionUpdateEvent>("regen_motion_update_listener")
        {
            @Override
            public void call(MotionUpdateEvent event)
            {
                if (mode.getValue().equals(Mode.CONSTANT))
                {
                    if (ClientUtils.player().getHealth() <= health.getValue() * 2.0 && (ClientUtils.player().isCollidedVertically || isInsideBlock()) /*&& event.getTime() == MotionUpdateEvent.Time.BEFORE*/) {
                        for (int i = 0; i < packets.getValue(); ++i) {
                            ClientUtils.packet(new C03PacketPlayer(true));
                        }
                    }

                } else if (shouldRegen()) switch (mode.getValue())
                    {
                        case OLD:
                            for (int index = 0; index < minecraft.thePlayer.getMaxHealth() - minecraft.thePlayer.getHealth(); index++)
                            {
                                minecraft.func_175102_a().addToSendQueue(new C03PacketPlayer(minecraft.thePlayer.onGround));
                            }

                            break;

                        case POTION:
                            if (minecraft.thePlayer.isPotionActive(Potion.regeneration))
                            {
                                for (int index = 0; index < minecraft.thePlayer.getMaxHealth() - minecraft.thePlayer.getHealth(); index++)
                                {
                                    minecraft.func_175102_a().addToSendQueue(new C03PacketPlayer(minecraft.thePlayer.onGround));
                                }
                            }

                            break;
                    }
            }
        });
    }

    private boolean isInsideBlock() {
        for (int x = MathHelper.floor_double(ClientUtils.player().boundingBox.minX); x < MathHelper.floor_double(ClientUtils.player().boundingBox.maxX) + 1; ++x) {
            for (int y = MathHelper.floor_double(ClientUtils.player().boundingBox.minY); y < MathHelper.floor_double(ClientUtils.player().boundingBox.maxY) + 1; ++y) {
                for (int z = MathHelper.floor_double(ClientUtils.player().boundingBox.minZ); z < MathHelper.floor_double(ClientUtils.player().boundingBox.maxZ) + 1; ++z) {
                    final Block block = ClientUtils.world().getBlockState(new BlockPos(x, y, z)).getBlock();
                    if (block != null && !(block instanceof BlockAir)) {
                        AxisAlignedBB boundingBox = block.getCollisionBoundingBox(ClientUtils.world(), new BlockPos(x, y, z), ClientUtils.world().getBlockState(new BlockPos(x, y, z)));
                        if (block instanceof BlockHopper) {
                            boundingBox = new AxisAlignedBB(x, y, z, x + 1, y + 1, z + 1);
                        }
                        if (boundingBox != null && ClientUtils.player().boundingBox.intersectsWith(boundingBox)) {
                            return true;
                        }
                    }
                }
            }
        }
        return false;
    }

    private boolean shouldRegen()
    {
        return minecraft.thePlayer.onGround && minecraft.thePlayer.isCollidedVertically && minecraft.thePlayer.getFoodStats().getFoodLevel() > 18 && !minecraft.thePlayer.isInWater() && !minecraft.thePlayer.isOnLadder() && minecraft.thePlayer.getHealth() < health.getValue();
    }

    public enum Mode
    {
        OLD, POTION, CONSTANT
    }
}